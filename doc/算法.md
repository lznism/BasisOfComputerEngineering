### 1. 基础
#### 1.1 基础编程模型
Java最基本的4中数据类型
- 整型
- 浮点型
- 布尔型
- 字符型

初级的加减乘除运算产生的数据的数据类型和参与运算的数据的数据类型是相同的

```java
5 / 3 // 1
5.0 / 3.0 // 1.6666666667
```

声明一个数组，在一个Java数组中，double类型的变量默认的初始值都是`0.0`，如果你需要给数组初始化别的值，那么你就需要使用for循环来赋值了。另外，**数值类型的默认初始值是0，布尔类型的默认初始值是false**。如果访问数组时越界，则会抛出`ArrayOutOfBoundsException`异常。

如果将一个数组变量赋给另外一个数组变量，那么两个变量将会指向同一个数组。如果想要深拷贝一个数组，那么就需要用到遍历了。

```java
double[] a = new double[10];
// 创建一个多维数组
int M, N;
double[][] a = new double[M][N];
```

编写递归代码重要的三点
- 递归总有一个最简单的情况
- 递归调用总是去尝试解决一个规模更小的子问题，这样才能递归收敛到最简单的情况
- 递归调用的父问题和尝试解决的子问题之间不应该有交集

在Java中字符串的一个重要用途就是使程序能够接收到命令行传递过来的信息。

#### 1.2 数据抽象
每当调用了new()，就会完成以下步骤：
- 为新的对象分配内存空间；
- 调用构造函数初始化对象中的值；
- 返回该对象的一个引用

静态方法的主要作用是实现函数，非静态方法的主要作用是实现数据类型的操作。

如果我们需要开发某种给定数据类型的用例，我们需要：
- 声明该类型的变量，用来引用对象
- 使用关键字new触发能够创建该类型的对象的一个构造函数
- 使用变量名在语句或表达式中调用实例方法

Java中的数据类型可以分为`不可变数据类型`和`可变数据类型`

- 不可变数据类型：该类型的对象中的值在创建之后就无法再改变
- 可变数据类型：能够操作并改变对象中的值

Java中通过final修饰符来强制保证数据的不可变性，数据类型的不可变是一个重要的设计决策，它取决于当前的应用场景

Java中我们可以手动创建自己的异常，最简单的一种是`RuntimeException`，它会中断程序的执行并打印出一条出错的信息

```java
throw new RuntimeException("Error message here");
```

Java最重要的一个特性就是自动内存管理。他通过记录孤儿对象并将它们的内存释放到内存池中将程序员从管理内存的责任中解放出来。

断言是一条需要在程序的某处确认为true的布尔表达式。如果表达式的值为false,程序将会终止并报告出一条出错的信息，还可以选择性的加上一条详细消息来辅助定位bug

```java
assert index >= 0 : 'Negative index in method X';
```

程序正常操作中不应该依赖断言，因为它们可能会被禁用。

#### 1.3 背包、队列和栈
类名后面的`<Item>`记号将Item定义为一个类型参数，它是一个象征性的占位符，表示的是用例将会使用某种类型的数据类型。

```java
Stack<String> stack = new Stack<String>();
```

有了泛型，我们只需要一份API就能够处理所有的数据类型。

背包是一种不支持从中删除元素的集合数据类型。它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素。

#### 2.1 选择排序
选择排序的主要思想：（主要就是**选择最小数**）
- 选择数组中最小的数，跟第一个交换（如果第一个本身就是最小的，那么自己和自己交换）
- 从剩下的数中选择一个最小的数，跟第二个交换
- 如此重复，则可对数组排序

选择排序有如下特点：
- 运行时间与输入无关，即使数组一开始就是排序好的，也要进行那么多次对比
- 数据的移动是最少的，只需要交换最小值和前面的值，总共交换了N次

```java
public class SelectSort {
    public static void sort(Comparable[] arr) {
        int N = arr.length;
        for (int i = 0; i < N; i++) {
            int min = i;
            for (int j = i + 1; j < N; j++) {
                if (arr[min] > arr[j]) {
                    min = j;
                }
            }
            int temp = arr[i];
            arr[i] = arr[min];
            arr[min] = temp;
        }
    }
}
```

#### 2.2 插入排序
插入排序主要思想：（依次向前构造一个有序的数组）
- 假定第一个元素是有序的
- 用第二个元素与前一个（第一个）元素比较，如果小于第一个则交换
- 用第三个元素与前两个元素比较，如果小，则依次往前移

插入排序最差的情况下需要~N^2/2次比较和~N^2/2次交换；最好的情况下需要N-1次比较和0次交换

```java
public class Insertion {
    public static int[] sort(int[] arr) {
        int len = arr.length;

        for (int i = 1; i < len; i++) {
            for (int j = i; j > 0 && arr[j] < arr[j-1]; j--) {
                int temp = arr[j];
                arr[j] = arr[j-1];
                arr[j-1] = temp;
            }
        }

        return arr;
    }
}
```

插入法排序对于数组本身有一定次序的数组，排序起来更有优势

#### 2.3 希尔排序
希尔排序是基于插入排序的，因为插入排序仅仅会交换相邻的元素，而对于希尔排序而言，采用了一个增量h，比如

```
1 1+h 1+2h 1+3h...1+nh
2 2+h 2+2h 2+3h...2+nh
```

相当于将原数组划分为了几个子数组，对每个子数组使用插入排序，然后依次减小增量h，在h=1时完成整个希尔排序

```java
public class Shell {
    public static int[] sort(int[] arr) {
        int len = arr.length;
        int h = 1;
        while(h < len/3) {
            h = 3*h + 1; // 构造一个递增序列（但至今无法找出最优的递增序列）
        }
        while(h >= 1) {
            for (int i = h; i < len; i++) {
                for (int j = i; j >= h && a[j] < a[j-h]; j -= h) {
                    int temp = a[j];
                    a[j] = a[j-h];
                    a[j-h] = temp;
                }
            }
            h = h / 3;
        }
        return arr;
    }
}
```